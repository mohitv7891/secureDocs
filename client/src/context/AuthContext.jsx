// client/context/AuthContext.jsx
import React, { createContext, useState, useContext, useEffect, useCallback } from 'react';
import { jwtDecode } from 'jwt-decode'; // Ensure installed: npm install jwt-decode
import axios from 'axios'; // Ensure installed: npm install axios
import { decryptKeyWithPasswordJS } from '../utils/cryptoUtils.js'; // Import JS decryption utility

// Get URLs from environment variables
const KDC_BASE_URL = import.meta.env.VITE_KDC_BASE_URL; // e.g., http://localhost:5007/api
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL; // e.g., http://localhost:5006/api

// --- Axios instance configured for the DATA SERVER (port 5006) ---
// Used for file operations (upload, download, list) AFTER login
const apiClient = axios.create({ baseURL: API_BASE_URL });

// --- Axios instance configured for the KDC SERVER (port 5007) ---
// Used for authentication operations (login, register, verify OTP)
const kdcClient = axios.create({ baseURL: KDC_BASE_URL });

// Interceptor for DATA SERVER requests: Adds JWT token automatically
apiClient.interceptors.request.use(
    (config) => {
        const token = localStorage.getItem('token'); // Get token generated by KDC
        if (token && !config.headers['Authorization']) {
            config.headers['Authorization'] = `Bearer ${token}`;
            console.debug("apiClient Interceptor: Added token to request to Data Server:", config.url);
        }
        return config;
    },
    (error) => Promise.reject(error)
);
// Note: No interceptor needed for kdcClient as login/register happen before token exists.

// Create Context
const AuthContext = createContext(null);

// Create Provider Component
export const AuthProvider = ({ children }) => {
    const [token, setToken] = useState(() => localStorage.getItem('token'));
    const [user, setUser] = useState(null);
    const [encryptedKeyFileContent, setEncryptedKeyFileContent] = useState(null); // ArrayBuffer of loaded .dat file
    const [decryptedPrivateKeyBuffer, setDecryptedPrivateKeyBuffer] = useState(null); // Uint8Array of raw key
    const [isDecryptingKey, setIsDecryptingKey] = useState(false);
    const [keyDecryptionError, setKeyDecryptionError] = useState(null);

    // --- Logout Function ---
    const logout = useCallback(() => {
        localStorage.removeItem('token');
        setToken(null);
        setUser(null);
        setEncryptedKeyFileContent(null);
        setDecryptedPrivateKeyBuffer(null);
        setIsDecryptingKey(false);
        setKeyDecryptionError(null);
        console.log("AuthContext: User logged out, keys cleared.");
    }, []);

    // --- Login Function (Hits KDC) ---
    const login = useCallback(async (email, password) => {
        if (!KDC_BASE_URL) {
            console.error("AuthContext Login Error: KDC_BASE_URL is not defined!");
            throw new Error("Authentication service URL not configured.");
        }
        console.log("AuthContext: Attempting login via KDC...");
        // Clear previous keys/errors on new login attempt
        setEncryptedKeyFileContent(null);
        setDecryptedPrivateKeyBuffer(null);
        setKeyDecryptionError(null);
        try {
            // Use the kdcClient instance to hit the KDC server's login endpoint
            const response = await kdcClient.post(`/auth/login`, { email, password });
            const newToken = response.data.token;
            if (!newToken) throw new Error("No token received from KDC");

            // Store token, decode user info, update state
            localStorage.setItem('token', newToken);
            const decodedPayload = jwtDecode(newToken); // Decode the whole payload
            const userData = decodedPayload.user; // Extract user object { id, email }
            if (!userData || !userData.email) {
                throw new Error("Invalid token payload structure from KDC");
            }

            setToken(newToken);
            setUser(userData);
            console.log("AuthContext: Login successful, user set:", userData.email);
            // Key is NOT fetched here. User needs to load file & enter password via UI.
            return true; // Indicate login success

        } catch (error) {
            console.error("AuthContext: Login failed:", error.response ? error.response.data : error.message);
            logout(); // Ensure cleanup on failed login
            throw error; // Re-throw the error for the Login component to display message
        }
    }, [logout]); // Dependency on logout

    // --- Decrypt Key Function (Uses JS Crypto Utility) ---
    const decryptAndLoadKey = useCallback(async (password, encryptedKeyBuffer) => {
        if (!encryptedKeyBuffer || !password) {
             setKeyDecryptionError("Missing password or encrypted key data.");
             return;
        }
        if (!window.crypto?.subtle) {
             setKeyDecryptionError("Web Crypto API (SubtleCrypto) is not available. Browser might be too old or insecure.");
             return;
        }

        console.log("AuthContext: Attempting to decrypt private key using JS Crypto...");
        setIsDecryptingKey(true);
        setKeyDecryptionError(null);
        setDecryptedPrivateKeyBuffer(null); // Clear previous key

        try {
             // Call the imported JavaScript decryption function
             const rawKeyUint8Array = await decryptKeyWithPasswordJS(password, encryptedKeyBuffer);

             if (!rawKeyUint8Array || rawKeyUint8Array.length === 0) {
                 throw new Error("JS Decryption resulted in empty key data.");
             }

             setDecryptedPrivateKeyBuffer(rawKeyUint8Array); // Store the raw key bytes (Uint8Array)
             console.log("AuthContext: Private key decrypted via JS and loaded successfully.");
             setEncryptedKeyFileContent(encryptedKeyBuffer); // Keep loaded encrypted buffer

        } catch (error) {
             console.error("AuthContext: JS Key decryption failed:", error);
             setKeyDecryptionError(error.message || "Failed to decrypt key. Check password or key file.");
             setDecryptedPrivateKeyBuffer(null);
        } finally {
             setIsDecryptingKey(false);
        }
    }, []); // No external dependencies needed here

    // --- Effect for Initial Load (Checks existing token) ---
    useEffect(() => {
        const storedToken = localStorage.getItem('token');
        if (storedToken) {
            try {
                const decodedPayload = jwtDecode(storedToken);
                const userData = decodedPayload.user;
                const currentTime = Date.now() / 1000;

                if (!userData || !userData.email || decodedPayload.exp < currentTime) {
                    console.log("AuthContext InitialLoad: Invalid or expired token found.");
                    logout(); // Clear invalid/expired token
                } else {
                    setToken(storedToken);
                    setUser(userData);
                    console.log("AuthContext InitialLoad: Valid token found for user:", userData.email);
                    // Note: Key is NOT loaded here automatically.
                }
            } catch (error) {
                console.error("AuthContext InitialLoad: Error processing stored token", error);
                logout(); // Clear corrupted token
            }
        }
    }, [logout]); // Dependency on logout

    // --- Value provided to consuming components ---
    const value = {
        token,
        user,
        isAuthenticated: !!token,
        login,
        logout,
        apiClient, // For Data Server API calls (port 5006)
        kdcClient, // For KDC API calls (port 5007)
        // Key Management State & Functions
        encryptedKeyFileContent,
        decryptedPrivateKeyBuffer, // The raw key (Uint8Array) for WASM
        isDecryptingKey,
        keyDecryptionError,
        decryptAndLoadKey,
        setEncryptedKeyFileContent, // Allow UI to store the loaded file buffer
    };

    return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// Custom hook to use the AuthContext
export const useAuth = () => {
    const context = useContext(AuthContext);
    if (context === null) {
        throw new Error("useAuth must be used within an AuthProvider");
    }
    return context;
};